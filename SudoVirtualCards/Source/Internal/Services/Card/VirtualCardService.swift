//
// Copyright Â© 2022 Anonyome Labs, Inc. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

import Foundation
import AWSAppSync
import SudoUser
import SudoLogging
import SudoApiClient

/// Abstraction of the SDKs capabilities surrounding `VirtualCard` access/manipulation with virtual cards service.
class VirtualCardService {

    /// Default values used in `CardService`.
    enum Defaults {
        /// Limit used when listing cards. 100 was set as it is unlikely a user will go over this number.
        static let provisionalCardListLimit = 100
        /// Timeout for a provision card observer before it is removed.
        static let provisionTimeout = 60.0
    }

    // MARK: - Properties

    /// App Sync Client used to interact with the GraphQL endpoint of the virtual cards service.
    private unowned let graphQLClient: SudoApiClient

    /// Unsealer used to unseal card data that has been encrypted.
    private unowned let unsealer: Unsealer

    private unowned let platformKeyManager: PlatformKeyManager

    /// Logs errors and diagnostic information.
    private let logger: Logger

    /// Dictionary of Timers used to cancel a provision card subscription if it times out.
    var provisionTimers: [String: Timer] = [:]

    /// Dictionary of subscriber objects to cancel the subscription events created internally
    /// while provisioning a card. The id is the generated `clientRefId`.
    var provisionSubscriptions: [String: Cancellable] = [:]

    // MARK: - Lifecycle

    /// Initialize an instance of `CardService`.
    init(graphQLClient: SudoApiClient, unsealer: Unsealer, platformKeyManager: PlatformKeyManager, logger: Logger = .virtualCardsSDKLogger) {
        self.graphQLClient = graphQLClient
        self.unsealer = unsealer
        self.platformKeyManager = platformKeyManager
        self.logger = logger
    }

    /// Cancel all subscriptions in `CardService`.
    func clearSubscriptions() {
        provisionSubscriptions.keys.forEach {
            self.removeProvisionObserver(withClientRefId: $0)
        }
    }

    // MARK: - CardService

    /// Create a card.
    ///
    /// Calls the mutation to create a card against the GraphQL endpoint of the virtual cards service.
    ///
    /// - Parameters:
    ///   - input: Input supplied by the user.
    ///   - publicKey: Registered public key used to encrypt the card information.
    ///   - owner: Owner identifier of user. This is the user's account identifier.
    ///   - clientRefId: Client reference identifier generated by the `DefaultSudoVirtualCardsClient`.
    /// - Returns:
    ///     - Success: The cards provisioning state (this will be `.provisioning`).
    ///     - Failure: Any `Error` that may have occurred during the provisioning of the card, either internally or from the service.
    func create(
        withInput input: ProvisionVirtualCardInput,
        publicKey: PublicKey,
        owner: String,
        clientRefId: String
    ) async throws -> ProvisionalCardState {
        // Double optional on purpose to ensure that gets passed as undefined on nil
        let billingAddressInput: GraphQL.AddressInput??
        if let address = input.billingAddress {
            billingAddressInput = GraphQL.AddressInput(
                addressLine1: address.addressLine1,
                addressLine2: address.addressLine2,
                city: address.city,
                country: address.country,
                postalCode: address.postalCode,
                state: address.state
            )
        } else {
            billingAddressInput = Optional(nil)
        }
        // Double optional on purpose to ensure that gets passed as undefined on nil
        let metadataInput: GraphQL.SealedAttributeInput??
        if let metadata = try sealMetadata(input.metadata) {
            metadataInput = metadata
        } else {
            metadataInput = Optional(nil)
        }
        // Double optional on purpose to ensure that gets passed as undefined on nil
        let aliasInput: String??
        if let alias = input.alias {
            aliasInput = alias
        } else {
            aliasInput = Optional(nil)
        }
        let request = GraphQL.CardProvisionRequest(
            alias: aliasInput,
            billingAddress: billingAddressInput,
            cardHolder: input.cardHolder,
            clientRefId: clientRefId,
            currency: input.currency,
            fundingSourceId: input.fundingSourceId,
            keyRingId: publicKey.keyRingId,
            metadata: metadataInput,
            ownerProofs: [input.ownershipProof]
        )
        let mutation = GraphQL.ProvisionVirtualCardMutation(input: request)
        let (optimisticUpdate, optimisticCleanup) = generateOptimisticBlocks(owner: owner, clientRefId: clientRefId)
        let data = try await GraphQLHelper.performMutation(
            graphQLClient: graphQLClient,
            serviceErrorTransformations: [SudoVirtualCardsError.init(graphQLError:)],
            mutation: mutation,
            optimisticUpdate: optimisticUpdate,
            optimisticCleanup: optimisticCleanup,
            logger: logger
        )
        return ProvisionalCardState(data.cardProvision.provisioningState)
    }

    func update(
        withInput input: UpdateVirtualCardInput,
        keyId: String
    ) async throws -> SingleAPIResult<VirtualCard, PartialVirtualCard> {
        var request = GraphQL.CardUpdateRequest(cardHolder: input.cardHolder, id: input.id, keyId: keyId)
        switch input.alias {
        case .null:
            // Must be single optional to ensure that is passed as null
            let alias: String? = nil
            request.alias = alias
        case .undefined:
            let alias: String?? = nil
            request.alias = alias
        case .defined(let alias):
            request.alias = alias
        }

        switch input.billingAddress {
        case .null:
            // Must be single optional to ensure that is passed as null
            let billingAddress: GraphQL.AddressInput? = nil
            request.billingAddress = billingAddress
        case .undefined:
            let billingAddress: GraphQL.AddressInput?? = nil
            request.billingAddress = billingAddress
        case .defined(let address):
            request.billingAddress = GraphQL.AddressInput(
                addressLine1: address.addressLine1,
                addressLine2: address.addressLine2,
                city: address.city,
                country: address.country,
                postalCode: address.postalCode,
                state: address.state
            )
        }
        switch input.metadata {
        case .null:
            // Must be single optional to ensure that is passed as null
            let metadata: GraphQL.SealedAttributeInput? = nil
            request.metadata = metadata
        case .undefined:
            let metadata: GraphQL.SealedAttributeInput?? = nil
            request.metadata = metadata
        case .defined(let value):
            request.metadata = try sealMetadata(value)
        }

        if let expectedCardVersion = input.expectedCardVersion {
            request.expectedVersion = expectedCardVersion
        }

        let mutation = GraphQL.UpdateVirtualCardMutation(input: request)
        let data = try await GraphQLHelper.performMutation(
            graphQLClient: graphQLClient,
            serviceErrorTransformations: [SudoVirtualCardsError.init(graphQLError:)],
            mutation: mutation,
            logger: logger
        )
        do {
            let result = try unsealer.unseal(data.updateCard.fragments.sealedCardWithLastTransaction)
            return .success(result)
        } catch {
            let card = data.updateCard.fragments.sealedCardWithLastTransaction
            return .partial(PartialResult(card: card, error: error))
        }
    }

    /// Add a provision observer to watch for a card provisioning event with the `clientRefId`.
    /// - Parameters:
    ///   - observer: Observer to add to service.
    ///   - clientRefId: Client reference identifier to watch events for.
    func addProvisionObserver(_ observer: ProvisionVirtualCardObservable, clientRefId: String) {
        var previousState: ProvisionalCardState = .unknown("uninitialized")
        let filter = GraphQL.ProvisionalCardFilterInput(clientRefId: .init(eq: clientRefId))
        let query = GraphQL.ListProvisionalCardsQuery(filter: filter, limit: Defaults.provisionalCardListLimit)
        var discard: Cancellable?
        discard = graphQLClient.getAppSyncClient().sync(
            baseQuery: query,
            baseQueryResultHandler: { [ clientRefId, weak self, weak observer] result, error in
                guard
                    let weakSelf = self,
                    let observer = observer
                else {
                    return
                }
                if let error = error {
                    weakSelf.removeProvisionObserver(withClientRefId: clientRefId)
                    observer.errorOccurred(error)
                    return
                }
                guard let result = result?.data?.listProvisionalCards.items.first(where: { $0.clientRefId == clientRefId}) else {
                    return
                }
                let newProvisionState = ProvisionalCardState(result.provisioningState)
                guard newProvisionState != previousState else {
                    return
                }
                previousState = newProvisionState
                if newProvisionState == .completed || newProvisionState == .failed {
                    weakSelf.removeProvisionObserver(withClientRefId: clientRefId)
                }
                var card: VirtualCard?
                if let resultCard = result.card {
                    do {
                        let sealedCards = resultCard.map { $0.fragments.sealedCard }
                        guard let cardToUnseal = try sealedCards.first(where: {
                            try weakSelf.platformKeyManager.getKeyPairWithId($0.keyId) != nil
                        }) else {
                            throw UnsealingError.keyNotFound
                        }
                        card = try weakSelf.unsealer.unseal(cardToUnseal)
                    } catch {
                        weakSelf.logger.error("Failed to unseal card: \(error)")
                        weakSelf.removeProvisionObserver(withClientRefId: clientRefId)
                        observer.errorOccurred(error)
                        return
                    }
                }
                observer.provisioningStateDidChange(newProvisionState, card: card)
            },
            syncConfiguration: .init(baseRefreshIntervalInSeconds: 1)
        )
        guard let cancellable = discard else {
            return
        }
        provisionSubscriptions[clientRefId] = cancellable
        let timeout = Timer.scheduledTimer(withTimeInterval: Defaults.provisionTimeout, repeats: false) { [weak self] _ in
            self?.logger.error("Provision card (\(clientRefId)) timed out.")
            self?.removeProvisionObserver(withClientRefId: clientRefId)
        }
        provisionTimers[clientRefId] = timeout
    }

    /// Remove a provision observer from the service with the `clientRefId`.
    func removeProvisionObserver(withClientRefId clientRefId: String) {
        provisionTimers.removeValue(forKey: clientRefId)?.invalidate()
        provisionSubscriptions.removeValue(forKey: clientRefId)?.cancel()
    }

    // MARK: - Helpers

    func sealMetadata(_ metadata: JSONValue?) throws -> GraphQL.SealedAttributeInput? {
        guard let metadata = metadata else {
            return nil
        }
        var secretKeyId = try platformKeyManager.getCurrentSymmetricKeyId()
        if secretKeyId == nil {
            secretKeyId = try platformKeyManager.generateNewCurrentSymmetricKey()
        }
        guard let secretKeyId = secretKeyId else {
            throw SudoVirtualCardsError.fatalError(description: "Unexpected nil key after generating new key")
        }
        let serializedMetadata = try JSONSerialization.data(withJSONObject: metadata.toSwiftObject(), options: [.fragmentsAllowed, .sortedKeys])
        let encryptedMetadata = try platformKeyManager.encrypt(withSymmetricKeyId: secretKeyId, data: serializedMetadata)
        return GraphQL.SealedAttributeInput(
            algorithm: SymmetricKeyEncryptionAlgorithm.aesCBCPKCS7Padding.rawValue,
            base64EncodedSealedData: encryptedMetadata.base64EncodedString(),
            keyId: secretKeyId,
            plainTextType: "json-string"
        )
    }

    /// Generates a `OptimisticResponseBlock` and `OptimisticCleanupBlock`.
    ///
    /// These blocks are used by the `PlatformMutationOperation` to perform a write to the store before the network call (for offline redundancy) and remove the
    /// write after a successful server mutation result.
    /// - Parameter owner: Owner ID associated with the user - retrieved from Sudo User service.
    func generateOptimisticBlocks(owner: String, clientRefId: String) -> (update: OptimisticResponseBlock, cleanup: OptimisticCleanupBlock) {
        let optimisticId = UUID().uuidString
        let update: OptimisticResponseBlock = { transaction in
            let query = GraphQL.ListProvisionalCardsQuery()
            do {
                try transaction?.update(
                    query: query, { (data: inout GraphQL.ListProvisionalCardsQuery.Data) in
                        var listProvisionalCards = data.listProvisionalCards
                        let nowSinceEpochMs = Date().millisecondsSince1970
                        let newItem = GraphQL.ListProvisionalCardsQuery.Data.ListProvisionalCard.Item(
                            id: optimisticId,
                            owner: owner,
                            version: 1,
                            createdAtEpochMs: nowSinceEpochMs,
                            updatedAtEpochMs: nowSinceEpochMs,
                            clientRefId: clientRefId,
                            provisioningState: .provisioning)
                        listProvisionalCards.items.append(newItem)
                        data.listProvisionalCards = listProvisionalCards
                    }
                )
            } catch {
                self.logger.error("failed to optimistically write record to cache: \(error)")
            }
        }
        let cleanup: OptimisticCleanupBlock = { transaction in
            let query = GraphQL.ListProvisionalCardsQuery()
            try transaction.update(query: query) { (data: inout GraphQL.ListProvisionalCardsQuery.Data) in
                let items = data.listProvisionalCards.items
                if let optimisticIndex = items.firstIndex(where: { $0.id == optimisticId }) {
                    data.listProvisionalCards.items.remove(at: optimisticIndex)
                }
            }
        }
        return (update, cleanup)
    }

}
