//
// Copyright Â© 2023 Anonyome Labs, Inc. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

import Foundation

// Representation of the signed authorization which includes
// enough information to validate that authorization has been granted.
internal struct AuthorizationTextSignature: Encodable, Hashable {
    // MARK: - Properties

    // Specifies the plaintext data to be signed
    let data: String
    // Specifies the algorithm used to sign this data
    let algorithm: String
    // Specifies the key pair id used to sign the data
    let keyId: String
    // Specifies the result of the signing operation
    let signature: String

    // MARK: - Conformance: Encodable

    enum CodingKeys: String, CodingKey {
        case data
        case algorithm
        case keyId
        case signature
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(data, forKey: .data)
        try container.encode(algorithm, forKey: .algorithm)
        try container.encode(keyId, forKey: .keyId)
        try container.encode(signature, forKey: .signature)
    }

    // MARK: - Lifecycle

    // Construct an AuthorizationTextSignature
    // - Parameters
    //  - data: Specifies the plaintext data representation of the authorization to be signed
    //  - algorithm: algorithm used to create the signature
    //  - keyId: ID of the registered public key against which to verify the signature
    //  - signature: Base64 encoded signature of the data
    init(data: String, algorithm: String, keyId: String, signature: String) {
        self.data = data
        self.algorithm = algorithm
        self.keyId = keyId
        self.signature = signature
    }
}

// Metadata (including a hash) of the authorization acknowledged by the user for accessing
// bank accounts to perform transactions and retrieve balance and transaction information.
// This data makes up the signed components of the authorization text signature for transmission
// and storage in the Virtual Cards service.
internal struct AuthorizationTextSignatureData: Encodable, Hashable {
    // MARK: - Properties

    // The hash of the specific content made available to the user to agree to
    let hash: String
    // The hash algorithm used to generate above hash
    let hashAlgorithm: String
    // ISO8601 UTC timestamp generated by client at signing time
    let signedAt: Date
    // Information identifing the account for authorization is being given
    let account: String

    // MARK: - Conformance: Encodable

    enum CodingKeys: String, CodingKey {
        case hash
        case hashAlgorithm
        case signedAt
        case account
    }

    func encode(to encoder: Encoder) throws {
        let dateFormatter = ISO8601DateFormatter()
        dateFormatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]

        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(hash, forKey: .hash)
        try container.encode(hashAlgorithm, forKey: .hashAlgorithm)
        try container.encode(dateFormatter.string(from: signedAt), forKey: .signedAt)
        try container.encode(account, forKey: .account)
    }

    // Construct an AuthorizationTextSignatureData
    //
    // - Parameters
    //  - hash: The hash of the specific content made available to the user to agree to
    //  - hashAlgorithm: The hash algorithm used to generate above hash
    //  - signedAt: ISO8601 UTC timestamp generated by client at signing time
    //  - account: Information identifing the account for authorization is being given
    init(hash: String, hashAlgorithm: String, signedAt: Date, account: String) {
        self.hash = hash
        self.hashAlgorithm = hashAlgorithm
        self.signedAt = signedAt
        self.account = account
    }
}
