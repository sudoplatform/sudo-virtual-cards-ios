//
// Copyright Â© 2023 Anonyome Labs, Inc. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

import Foundation

// Representation of the signed authorization which includes
// enough information to validate that authorization has been granted.
internal struct AuthorizationTextSignature: Encodable, Hashable {

    // MARK: - Properties

    /// Specifies the plaintext data to be signed
    let data: String

    /// Specifies the algorithm used to sign this data
    let algorithm: String

    /// Specifies the key pair id used to sign the data
    let keyId: String

    /// Specifies the result of the signing operation
    let signature: String

    // MARK: - Conformance: Encodable

    enum CodingKeys: String, CodingKey {
        case data
        case algorithm
        case keyId
        case signature
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(data, forKey: .data)
        try container.encode(algorithm, forKey: .algorithm)
        try container.encode(keyId, forKey: .keyId)
        try container.encode(signature, forKey: .signature)
    }
}

// Metadata (including a hash) of the authorization acknowledged by the user for accessing
// bank accounts to perform transactions and retrieve balance and transaction information.
// This data makes up the signed components of the authorization text signature for transmission
// and storage in the Virtual Cards service.
internal struct AuthorizationTextSignatureData: Encodable, Hashable {

    // MARK: - Properties

    /// The hash of the specific content made available to the user to agree to
    let hash: String

    /// The hash algorithm used to generate above hash
    let hashAlgorithm: String

    /// ISO8601 UTC timestamp generated by client at signing time
    let signedAt: Date

    /// Information identifying the account for authorization is being given
    let account: String

    // MARK: - Conformance: Encodable

    enum CodingKeys: String, CodingKey {
        case hash
        case hashAlgorithm
        case signedAt
        case account
    }

    func encode(to encoder: Encoder) throws {
        let dateFormatter = ISO8601DateFormatter()
        dateFormatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]

        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(hash, forKey: .hash)
        try container.encode(hashAlgorithm, forKey: .hashAlgorithm)
        try container.encode(dateFormatter.string(from: signedAt), forKey: .signedAt)
        try container.encode(account, forKey: .account)
    }
}
